<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title> Leetcode-多种方法解决“旋转数组”</title>
      <link href="/2018/06/10/Leetcode-%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E2%80%9C%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E2%80%9D/"/>
      <url>/2018/06/10/Leetcode-%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E2%80%9C%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E2%80%9D/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>摘自<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/23/" target="_blank" rel="noopener">leetcode中文版</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">    尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</span><br><span class="line">    要求使用空间复杂度为 O(1) 的原地算法。</span><br></pre></td></tr></table></figure><h2 id="数组切片拼接"><a href="#数组切片拼接" class="headerlink" title="数组切片拼接"></a>数组切片拼接</h2><p>最简单直接，也比较Pythonic的方法是数组的切片拼接，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&gt;<span class="number">1</span>:          </span><br><span class="line">            length = len(nums)</span><br><span class="line">            k = k%length</span><br><span class="line">            <span class="keyword">if</span> k&gt;<span class="number">0</span>:</span><br><span class="line">                newnums = nums[length-k:] + nums[:length-k]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">                    nums[i]=newnums[i]</span><br></pre></td></tr></table></figure></p><p>这个算法的最后进行了数组的逐个拷贝，是因为这里要求原地（in-place）算法，如果直接使用数组赋值nums=newnums将是错误的。<br>不过实际上这个算法也没有达到原题要求的空间复杂度O(1)的要求，因为我们使用了一个额外的长度为n的数组。</p><h2 id="低效率的O-1-空间复杂度算法"><a href="#低效率的O-1-空间复杂度算法" class="headerlink" title="低效率的O(1)空间复杂度算法"></a>低效率的O(1)空间复杂度算法</h2><p>一种低效率的低空间复杂度算法的思路是每次旋转（右移）1，然后再调用这个旋转1的算法k次。如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateOne</span><span class="params">(self,nums)</span>:</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> length&gt;<span class="number">1</span>:</span><br><span class="line">            num_n_1 = nums[length<span class="number">-1</span>]</span><br><span class="line">            num_k = length<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> num_k&gt;=<span class="number">1</span>:</span><br><span class="line">                nums[num_k] = nums[num_k<span class="number">-1</span>]</span><br><span class="line">                num_k -= <span class="number">1</span></span><br><span class="line">            nums[<span class="number">0</span>] = num_n_1</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&gt;<span class="number">1</span>:</span><br><span class="line">            length = len(nums)</span><br><span class="line">            k = k%length</span><br><span class="line">            <span class="keyword">for</span> rnum <span class="keyword">in</span> range(k):</span><br><span class="line">                self.rotateOne(nums)</span><br></pre></td></tr></table></figure></p><p>其中rotateOne函数每次旋转数组1。这个算法显而易见的低效，在leetcode上无法通过最后一个测试例。</p><h2 id="较高效率的O-1-空间复杂度算法"><a href="#较高效率的O-1-空间复杂度算法" class="headerlink" title="较高效率的O(1)空间复杂度算法"></a>较高效率的O(1)空间复杂度算法</h2><p>算法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&gt;<span class="number">1</span>:</span><br><span class="line">            length = len(nums)</span><br><span class="line">            k = k%length</span><br><span class="line">            <span class="keyword">if</span> k&gt;<span class="number">0</span>:</span><br><span class="line">                move_num = <span class="number">0</span></span><br><span class="line">                move_pos = <span class="number">0</span></span><br><span class="line">                move_value = nums[move_pos]</span><br><span class="line">                <span class="keyword">while</span> move_num&lt;length:</span><br><span class="line">                    next_pos = (move_pos+k)%length                    </span><br><span class="line">                    <span class="keyword">while</span> next_pos!=move_pos:</span><br><span class="line">                        save_value = nums[next_pos]</span><br><span class="line">                        nums[next_pos] = move_value</span><br><span class="line">                        move_value = save_value</span><br><span class="line">                        next_pos=(next_pos+k)%length</span><br><span class="line">                        move_num+=<span class="number">1</span></span><br><span class="line">                    nums[move_pos]=move_value</span><br><span class="line">                    move_num+=<span class="number">1</span></span><br><span class="line">                    move_pos+=<span class="number">1</span></span><br><span class="line">                    move_value = nums[move_pos]</span><br></pre></td></tr></table></figure></p><p>这个算法的思路是从第一个元素开始进行旋转，逐个将旋转位置上的元素移到下一个位置，直到旋转到该元素的初始位置。同时使用一个变量记录被旋转的元素数量，显然完成所有旋转后旋转元素数量应该是数组长度。</p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 买卖股票的最佳时机 II</title>
      <link href="/2018/05/31/Leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
      <url>/2018/05/31/Leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/</url>
      <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>这个题目的<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/22/" target="_blank" rel="noopener">中文版</a>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line"></span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2 id="简单粗暴的穷举和递归"><a href="#简单粗暴的穷举和递归" class="headerlink" title="简单粗暴的穷举和递归"></a>简单粗暴的穷举和递归</h2><p>看到这个问题的第一个思路就是穷举了：求得所有可能的买卖组合的获利，然后将获利最高的组合输出作为结果。</p><p>同时为了简化问题，递归的想法也自然地出现了。假设如下一个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...]</span><br></pre></td></tr></table></figure><p>我们可以考虑第一笔交易是第一天买入，然后第二天卖出，那么这种情况下的最好收益可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收益<span class="number">1</span> = <span class="number">1</span> + 最佳收益([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...])</span><br></pre></td></tr></table></figure><p>也可以考虑第一笔交易是第一天买入，第三天卖出，这种情况下的最好收益可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收益<span class="number">2</span> = (<span class="number">3</span><span class="number">-1</span>)+ 最佳收益([<span class="number">4</span>,<span class="number">5</span>,...])</span><br></pre></td></tr></table></figure><p>如此类推，假设第一笔交易共有n种可能，那么最佳收益就是上述n种收益中的最大值。显然这是一个标准的递归算法，可以实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mvalue = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> startPos <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> endPos <span class="keyword">in</span> range(startPos+<span class="number">1</span>,len(prices),<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> prices[endPos]&gt;prices[startPos]:  <span class="comment">#一种可能的第一笔交易</span></span><br><span class="line">                        <span class="keyword">if</span> prices[endPos]-prices[startPos]+self.maxProfit(prices[endPos+<span class="number">1</span>:])&gt;mvalue:</span><br><span class="line">                            mvalue = prices[endPos]-prices[startPos]+self.maxProfit(prices[endPos+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> mvalue</span><br></pre></td></tr></table></figure><p>果然简单粗暴完成了任务。不过粗暴有粗暴的代价，提交答案后leetcode的返回的是201个测试用例通过了199个，在倒数第二个用例上遭遇了“超出时间限制”的错误。很显然，穷举的方法在算法效率上是有问题的。</p><h2 id="改进为自底向上的算法"><a href="#改进为自底向上的算法" class="headerlink" title="改进为自底向上的算法"></a>改进为自底向上的算法</h2><p>反思一下我们前面的实现，主要问题是我们求出了所有可能的交易组合，我们需要一种能将明显不合理的交易过滤的算法。</p><p>另外从递归算法角度，上述实现可以认为是自顶向下：我们将大数组的解拆分为一系列更小规模数组的解的组合。如果我们希望提升效率，一种思考方式是倒过来，使用自底向上的算法。换言之，这个算法的精髓是回答如下一个问题：如果已知一个数组的最高收益，那么如果这个数组右边增加一个元素，那么新数组的最高收益是多少？很明显，如果这个问题得到回答，那么我们可以从问题数组的第一个元素开始逐步获得最终解答。</p><p>假设如下一个数组[1,3,2,4,6,5]，可以看出最高收益是(3-1)+(6-2)=6。如果右边增加一个元素8，新的数组最高收益是多少？在下面我们用+-号分别标出了旧数组的两组交易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,3,2,4,6,5] + 8</span><br><span class="line"> + - +   -</span><br></pre></td></tr></table></figure><p>实际上，可以证明，一个已知最高收益的数组增加一个元素后，如果增加的元素可以形成一个交易并使得新数组的收益最高，那么这个交易的买入点要么是旧数组中最后一笔交易的买入点要么是旧数组中的最后一个元素。</p><p>这个证明其实不难，穷举各种可能即可。基于该证明，那么我们的新的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    cache=&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mvalue = <span class="number">0</span></span><br><span class="line">            saleArray = []</span><br><span class="line">            </span><br><span class="line">            cpos = <span class="number">0</span></span><br><span class="line">            newpos = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> newpos&lt;=len(prices)<span class="number">-1</span>:</span><br><span class="line">                newsale1=<span class="number">0</span></span><br><span class="line">                newsale2=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> len(saleArray)&gt;=<span class="number">1</span>:</span><br><span class="line">                    lastSale = saleArray[<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">if</span> prices[newpos]&gt;prices[lastSale[<span class="number">0</span>]]:</span><br><span class="line">                        newsale1=mvalue+prices[newpos]-prices[lastSale[<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">if</span> len(saleArray)==<span class="number">0</span> <span class="keyword">or</span> saleArray[<span class="number">-1</span>][<span class="number">1</span>]!=cpos:</span><br><span class="line">                    <span class="keyword">if</span> prices[newpos]&gt;prices[cpos]:</span><br><span class="line">                        newsale2 = mvalue+prices[newpos]-prices[cpos]</span><br><span class="line">                <span class="keyword">if</span> newsale1&gt;=newsale2 <span class="keyword">and</span> newsale1&gt;mvalue:</span><br><span class="line">                    ls = saleArray.pop()</span><br><span class="line">                    saleArray.append((ls[<span class="number">0</span>],newpos))</span><br><span class="line">                    mvalue=newsale1</span><br><span class="line">                <span class="keyword">elif</span> newsale2&gt;newsale1 <span class="keyword">and</span> newsale2&gt;mvalue:</span><br><span class="line">                    saleArray.append((cpos,newpos))</span><br><span class="line">                    mvalue=newsale2</span><br><span class="line">                cpos+=<span class="number">1</span></span><br><span class="line">                newpos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mvalue</span><br></pre></td></tr></table></figure><p>这个实现顺利通过所有测试，不过明显比递归版本复杂多了。</p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
