<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Leetcode 买卖股票的最佳时机 II</title>
      <link href="/2018/05/31/Leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
      <url>/2018/05/31/Leetcode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/</url>
      <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>这个题目的<a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/22/" target="_blank" rel="noopener">中文版</a>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line"></span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2 id="简单粗暴的穷举和递归"><a href="#简单粗暴的穷举和递归" class="headerlink" title="简单粗暴的穷举和递归"></a>简单粗暴的穷举和递归</h2><p>看到这个问题的第一个思路就是穷举了：求得所有可能的买卖组合的获利，然后将获利最高的组合输出作为结果。</p><p>同时为了简化问题，递归的想法也自然地出现了。假设如下一个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...]</span><br></pre></td></tr></table></figure><p>我们可以考虑第一笔交易是第一天买入，然后第二天卖出，那么这种情况下的最好收益可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收益<span class="number">1</span> = <span class="number">1</span> + 最佳收益([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,...])</span><br></pre></td></tr></table></figure><p>也可以考虑第一笔交易是第一天买入，第三天卖出，这种情况下的最好收益可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收益<span class="number">2</span> = (<span class="number">3</span><span class="number">-1</span>)+ 最佳收益([<span class="number">4</span>,<span class="number">5</span>,...])</span><br></pre></td></tr></table></figure><p>如此类推，假设第一笔交易共有n种可能，那么最佳收益就是上述n种收益中的最大值。显然这是一个标准的递归算法，可以实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mvalue = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> startPos <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> endPos <span class="keyword">in</span> range(startPos+<span class="number">1</span>,len(prices),<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> prices[endPos]&gt;prices[startPos]:  <span class="comment">#一种可能的第一笔交易</span></span><br><span class="line">                        <span class="keyword">if</span> prices[endPos]-prices[startPos]+self.maxProfit(prices[endPos+<span class="number">1</span>:])&gt;mvalue:</span><br><span class="line">                            mvalue = prices[endPos]-prices[startPos]+self.maxProfit(prices[endPos+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> mvalue</span><br></pre></td></tr></table></figure><p>果然简单粗暴完成了任务。不过粗暴有粗暴的代价，提交答案后leetcode的返回的是201个测试用例通过了199个，在倒数第二个用例上遭遇了“超出时间限制”的错误。很显然，穷举的方法在算法效率上是有问题的。</p><h2 id="改进为自底向上的算法"><a href="#改进为自底向上的算法" class="headerlink" title="改进为自底向上的算法"></a>改进为自底向上的算法</h2><p>反思一下我们前面的实现，主要问题是我们求出了所有可能的交易组合，我们需要一种能将明显不合理的交易过滤的算法。</p><p>另外从递归算法角度，上述实现可以认为是自顶向下：我们将大数组的解拆分为一系列更小规模数组的解的组合。如果我们希望提升效率，一种思考方式是倒过来，使用自底向上的算法。换言之，这个算法的精髓是回答如下一个问题：如果已知一个数组的最高收益，那么如果这个数组右边增加一个元素，那么新数组的最高收益是多少？很明显，如果这个问题得到回答，那么我们可以从问题数组的第一个元素开始逐步获得最终解答。</p><p>假设如下一个数组[1,3,2,4,6,5]，可以看出最高收益是(3-1)+(6-2)=6。如果右边增加一个元素8，新的数组最高收益是多少？在下面我们用+-号分别标出了旧数组的两组交易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,3,2,4,6,5] + 8</span><br><span class="line"> + - +   -</span><br></pre></td></tr></table></figure><p>实际上，可以证明，一个已知最高收益的数组增加一个元素后，如果增加的元素可以形成一个交易并使得新数组的收益最高，那么这个交易的买入点要么是旧数组中最后一笔交易的买入点要么是旧数组中的最后一个元素。</p><p>这个证明其实不难，穷举各种可能即可。基于该证明，那么我们的新的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    cache=&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mvalue = <span class="number">0</span></span><br><span class="line">            saleArray = []</span><br><span class="line">            </span><br><span class="line">            cpos = <span class="number">0</span></span><br><span class="line">            newpos = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> newpos&lt;=len(prices)<span class="number">-1</span>:</span><br><span class="line">                newsale1=<span class="number">0</span></span><br><span class="line">                newsale2=<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> len(saleArray)&gt;=<span class="number">1</span>:</span><br><span class="line">                    lastSale = saleArray[<span class="number">-1</span>]</span><br><span class="line">                    <span class="keyword">if</span> prices[newpos]&gt;prices[lastSale[<span class="number">0</span>]]:</span><br><span class="line">                        newsale1=mvalue+prices[newpos]-prices[lastSale[<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">if</span> len(saleArray)==<span class="number">0</span> <span class="keyword">or</span> saleArray[<span class="number">-1</span>][<span class="number">1</span>]!=cpos:</span><br><span class="line">                    <span class="keyword">if</span> prices[newpos]&gt;prices[cpos]:</span><br><span class="line">                        newsale2 = mvalue+prices[newpos]-prices[cpos]</span><br><span class="line">                <span class="keyword">if</span> newsale1&gt;=newsale2 <span class="keyword">and</span> newsale1&gt;mvalue:</span><br><span class="line">                    ls = saleArray.pop()</span><br><span class="line">                    saleArray.append((ls[<span class="number">0</span>],newpos))</span><br><span class="line">                    mvalue=newsale1</span><br><span class="line">                <span class="keyword">elif</span> newsale2&gt;newsale1 <span class="keyword">and</span> newsale2&gt;mvalue:</span><br><span class="line">                    saleArray.append((cpos,newpos))</span><br><span class="line">                    mvalue=newsale2</span><br><span class="line">                cpos+=<span class="number">1</span></span><br><span class="line">                newpos+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mvalue</span><br></pre></td></tr></table></figure><p>这个实现顺利通过所有测试，不过明显比递归版本复杂多了。</p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
